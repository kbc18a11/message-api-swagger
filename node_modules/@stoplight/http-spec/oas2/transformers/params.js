"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.translateToPathParameter = exports.translateToQueryParameter = exports.translateFromFormDataParameters = exports.translateToBodyParameter = exports.translateToHeaderParams = exports.translateToHeaderParam = void 0;
const types_1 = require("@stoplight/types");
const lodash_1 = require("lodash");
const schema_1 = require("../../oas/transformers/schema");
const utils_1 = require("../../utils");
const getExamplesFromSchema_1 = require("./getExamplesFromSchema");
function chooseQueryParameterStyle(parameter) {
    switch (parameter.collectionFormat) {
        case 'pipes':
            return types_1.HttpParamStyles.PipeDelimited;
        case 'ssv':
            return types_1.HttpParamStyles.SpaceDelimited;
        case 'csv':
            return types_1.HttpParamStyles.CommaDelimited;
        case 'multi':
        default:
            return types_1.HttpParamStyles.Form;
    }
}
function translateToHeaderParam(document, parameter) {
    return lodash_1.pickBy(Object.assign(Object.assign({}, buildSchemaForParameter(document, parameter)), { name: parameter.name, style: types_1.HttpParamStyles.Simple, required: parameter.required }));
}
exports.translateToHeaderParam = translateToHeaderParam;
function translateToHeaderParams(document, headers) {
    return lodash_1.map(headers, (header, name) => {
        const { schema, description } = buildSchemaForParameter(document, Object.assign({ name }, header));
        const param = {
            name,
            style: types_1.HttpParamStyles.Simple,
            schema,
            description,
        };
        return param;
    });
}
exports.translateToHeaderParams = translateToHeaderParams;
function translateToBodyParameter(document, body, consumes) {
    const examples = lodash_1.map(lodash_1.get(body, 'x-examples') || (body.schema ? getExamplesFromSchema_1.getExamplesFromSchema(body.schema) : void 0), (value, key) => ({ key, value }));
    return lodash_1.pickBy({
        description: body.description,
        required: body.required,
        contents: consumes.map(mediaType => {
            return {
                mediaType,
                schema: utils_1.isDictionary(body.schema) ? schema_1.translateSchemaObject(document, body.schema) : void 0,
                examples,
            };
        }),
    });
}
exports.translateToBodyParameter = translateToBodyParameter;
function translateFromFormDataParameters(document, parameters, consumes) {
    const finalBody = {
        contents: consumes.map(mediaType => ({
            mediaType,
            schema: {
                $schema: 'http://json-schema.org/draft-07/schema#',
                type: 'object',
            },
        })),
    };
    return parameters.reduce((body, parameter) => {
        const { schema, description } = buildSchemaForParameter(document, parameter);
        (body.contents || []).forEach(content => {
            delete schema.$schema;
            if (description) {
                schema.description = description;
            }
            lodash_1.set(content, `schema.properties.${parameter.name}`, schema);
            if (parameter.required) {
                const requiredIndex = lodash_1.get(content, 'schema.required.length', 0);
                lodash_1.set(content, `schema.required.${requiredIndex}`, parameter.name);
            }
            if (parameter.collectionFormat) {
                content.encodings = content.encodings || [];
                const encoding = buildEncoding(parameter);
                if (encoding) {
                    content.encodings.push(encoding);
                }
            }
        });
        return body;
    }, finalBody);
}
exports.translateFromFormDataParameters = translateFromFormDataParameters;
function buildEncoding(parameter) {
    switch (parameter.collectionFormat) {
        case 'csv':
            return {
                property: parameter.name,
                style: types_1.HttpParamStyles.CommaDelimited,
                explode: false,
            };
        case 'pipes':
            return {
                property: parameter.name,
                style: types_1.HttpParamStyles.PipeDelimited,
                explode: false,
            };
        case 'multi':
            return {
                property: parameter.name,
                style: types_1.HttpParamStyles.Form,
                explode: true,
            };
        case 'ssv':
            return {
                property: parameter.name,
                style: types_1.HttpParamStyles.SpaceDelimited,
                explode: false,
            };
    }
    return null;
}
function translateToQueryParameter(document, query) {
    return lodash_1.pickBy(Object.assign(Object.assign({}, buildSchemaForParameter(document, query)), { allowEmptyValue: query.allowEmptyValue, name: query.name, style: chooseQueryParameterStyle(query), required: query.required }));
}
exports.translateToQueryParameter = translateToQueryParameter;
function translateToPathParameter(document, parameter) {
    return lodash_1.pickBy(Object.assign(Object.assign({}, buildSchemaForParameter(document, parameter)), { name: parameter.name, style: types_1.HttpParamStyles.Simple, required: parameter.required }));
}
exports.translateToPathParameter = translateToPathParameter;
function buildSchemaForParameter(document, param) {
    const schema = lodash_1.pick(param, 'type', 'format', 'default', 'enum', 'exclusiveMaximum', 'exclusiveMinimum', 'maxItems', 'maxLength', 'maximum', 'minItems', 'minimum', 'minLength', 'title', 'items', 'pattern', 'uniqueItems', 'multipleOf');
    if ('allowEmptyValue' in param && param.allowEmptyValue === false) {
        schema.minLength = 1;
    }
    return Object.assign({ schema: schema_1.translateSchemaObject(document, schema), description: param.description }, ('x-deprecated' in param && { deprecated: param['x-deprecated'] }));
}
//# sourceMappingURL=params.js.map