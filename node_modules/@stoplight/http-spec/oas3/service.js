"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformOas3Service = void 0;
const tslib_1 = require("tslib");
const lodash_1 = require("lodash");
const guards_1 = require("../oas/guards");
const translateLogo_1 = require("../oas/transformers/translateLogo");
const utils_1 = require("../utils");
const guards_2 = require("./guards");
const securities_1 = require("./transformers/securities");
const servers_1 = require("./transformers/servers");
exports.transformOas3Service = ({ document }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const httpService = {
        id: '?http-service-id?',
        version: (_b = (_a = document.info) === null || _a === void 0 ? void 0 : _a.version) !== null && _b !== void 0 ? _b : '',
        name: (_d = (_c = document.info) === null || _c === void 0 ? void 0 : _c.title) !== null && _d !== void 0 ? _d : 'no-title',
    };
    if (typeof ((_e = document.info) === null || _e === void 0 ? void 0 : _e.description) === 'string') {
        httpService.description = document.info.description;
    }
    if (typeof ((_f = document.info) === null || _f === void 0 ? void 0 : _f.summary) === 'string') {
        httpService.summary = document.info.summary;
    }
    if ((_g = document.info) === null || _g === void 0 ? void 0 : _g.contact) {
        httpService.contact = document.info.contact;
    }
    if (typeof ((_h = document.info) === null || _h === void 0 ? void 0 : _h.license) === 'object' && document.info.license !== null) {
        const _l = document.info.license, { name, identifier } = _l, license = tslib_1.__rest(_l, ["name", "identifier"]);
        httpService.license = Object.assign(Object.assign(Object.assign({}, license), { name: typeof name === 'string' ? name : '' }), (typeof identifier === 'string' && { identifier }));
    }
    if ((_j = document.info) === null || _j === void 0 ? void 0 : _j.termsOfService) {
        httpService.termsOfService = document.info.termsOfService;
    }
    if (utils_1.isDictionary(document.info) && guards_1.hasXLogo(document.info)) {
        httpService.logo = translateLogo_1.translateLogo(document.info);
    }
    const servers = lodash_1.compact(lodash_1.map(document.servers, server => {
        var _a, _b, _c;
        if (!server)
            return null;
        const serv = {
            name: (_b = (_a = document.info) === null || _a === void 0 ? void 0 : _a.title) !== null && _b !== void 0 ? _b : '',
            description: server.description,
            url: (_c = server.url) !== null && _c !== void 0 ? _c : '',
        };
        const variables = server.variables && servers_1.translateServerVariables(server.variables);
        if (variables && Object.keys(variables).length)
            serv.variables = variables;
        return serv;
    }));
    if (servers.length) {
        httpService.servers = servers;
    }
    const securitySchemes = lodash_1.compact(lodash_1.keys((_k = document.components) === null || _k === void 0 ? void 0 : _k.securitySchemes).map(key => {
        var _a, _b;
        const definition = (_b = (_a = document === null || document === void 0 ? void 0 : document.components) === null || _a === void 0 ? void 0 : _a.securitySchemes) === null || _b === void 0 ? void 0 : _b[key];
        return guards_2.isSecurityScheme(definition) && securities_1.transformToSingleSecurity(definition, key);
    }));
    if (securitySchemes.length) {
        httpService.securitySchemes = securitySchemes;
    }
    const security = lodash_1.compact(lodash_1.flatMap(document.security, sec => {
        if (!sec)
            return null;
        return lodash_1.keys(sec).map(key => {
            const ss = securitySchemes.find(securityScheme => securityScheme.key === key);
            if (ss && ss.type === 'oauth2') {
                const flows = {};
                for (const flowKey in ss.flows) {
                    const flow = ss.flows[flowKey];
                    flows[flowKey] = Object.assign(Object.assign({}, flow), { scopes: lodash_1.pickBy(flow.scopes, (_val, scopeKey) => {
                            const secKey = sec[key];
                            if (secKey)
                                return secKey.includes(scopeKey);
                            return false;
                        }) });
                }
                return Object.assign(Object.assign({}, ss), { flows });
            }
            return ss;
        });
    }));
    if (security.length) {
        httpService.security = security;
    }
    const tags = lodash_1.filter(document.tags, guards_2.isTagObject);
    if (tags.length) {
        httpService.tags = tags;
    }
    return httpService;
};
//# sourceMappingURL=service.js.map